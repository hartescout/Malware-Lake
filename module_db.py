# -*- coding: utf-8 -*-
"""
Created on Fri Mar 27 15:59:40 2020

@author: Danus
"""
import os
import requests
import pandas
import module_api_parser as api_parser
from zipfile import ZipFile
from datetime import date

"""
A const dictionary containing extraction settings for each database type
"""
const_dict_extract_type_db = {
    "Bazaar": {"columns":["Tags", "Delivery", "Source"], 
               "hash_col": "sha256_hash", 
               "api_func": api_parser.getDataBazaar},
    "Malshare": {"columns":["first_seen_utc", "file_type_guess", "Tags"], 
                 "hash_col": "sha256_hash", 
                 "api_func": api_parser.getDataMalshare},
    }


current_date = str(date.today())

current_dir = os.getcwd()

"""
Location of the master database
"""
current_main_db = "{0:s}\Main_test.csv".format(current_dir)

"""
Database Constructor
IN string_db_name - Name of the database
IN string_api_key - API key of the database
IN string_db_source - URL Location of the database
IN list_db_headers - A list of header fields that will be used in the database
IN isZipped - Boolean indicating if the raw database file is zipped or not
"""
class Database:
    
    def __init__(self, string_db_name, string_api_key, string_db_source, list_db_headers, isZipped=False):
        self.string_db_name = string_db_name
        self.string_api_key = string_api_key
        self.string_db_source = string_db_source
        self.list_db_headers = list_db_headers
        self.isZipped = isZipped
        
        self.string_db_path_full = "{0:s}/{1:s}/{2:s}_{3:s}".format(
            current_dir,
            string_db_name,
            current_date, 
            string_db_name)
        
        self.string_db_path_dir = "{0:s}/{1:s}/".format(
            current_dir,
            string_db_name)
        
        self.dataframe_db = None
        
    """
    This fuction unzips a compressed database file
    IN - The bytes of the zipped file
    IN - File object handle of the zipped file
    OUT - Contents of the extracted database file in bytes
    Assumes that there is only one file in the zip archive
    """
    def CleanDownloadedDatabase(self, num_trash_bytes):
        extracted_contents = ""
        file_name = ""
        if(self.isZipped == True):
            try:
                with ZipFile(self.string_db_path_full, 'r') as zipObj:
                    file_name = zipObj.namelist()
                    file_name = "{0:s}/{1:s}".format(self.string_db_path_dir, file_name[0])
                    zipObj.extractall(self.string_db_path_dir)
            except Exception as e:
                print(e)
                return False
            
            os.remove(self.string_db_path_full)
            os.rename(file_name, self.string_db_path_full)
        
        try:
            with open(self.string_db_path_full, 'rb') as extracted_file:
                extracted_contents = extracted_file.read()
        except Exception as e:
            print(e)
            return False
        
        try:
            with open(self.string_db_path_full, 'wb') as extracted_file:
                extracted_contents = extracted_contents[num_trash_bytes:]
                    
                """
                Cleans double qoutes and space character entries from the raw database
                """
                extracted_contents = extracted_contents.replace(b'\x20\x22', b'')
                extracted_contents = extracted_contents.replace(b'\x22', b'')
            
                extracted_file.write(extracted_contents)
        except Exception as e:
            print(e)
            return False
        
        return True
        
    
    """
    This function creates a raw database from the source provided to Database the object
    IN - Number of bytes to remove from the raw database outputp
    """    
    def createDatabase(self, num_trash_bytes):
        
        print("[{0:s}]Preparing Database creation!".format(self.string_db_name))
        
        """
        If the database folder doesnt exist, create it
        """
        if not os.path.exists(self.string_db_path_dir):
            os.mkdir(self.string_db_path_dir)
        
        """
        Check if a raw database already exists for the current date
        """
        if not os.path.exists(self.string_db_path_full):
            print("[{0:s}]Creating Database! URL:{1:s}".format(self.string_db_name, self.string_db_source))
            try:
                with requests.get(self.string_db_source, timeout=10) as response, open(self.string_db_path_full, 'wb' ) as out_file:
                    out_file.write(response.content)
            except Exception as e:
                print(e)
                print("[{0:s}]An error occurred during the database creation!".format(self.string_db_name))
            print("[{0:s}]Database created!".format(self.string_db_name))
        else:
            print("[{0:s}]Database already exists!".format(self.string_db_name))
               
        
        if(self.CleanDownloadedDatabase(num_trash_bytes) == False):
            print("[{0:s}]Unable to handle downloaded file!".format(self.string_db_name))
            return False
       

        print()
        return True
    
    """
    This function creates a pandas dataframe from a raw database of the Database Object
    OUT - 
    """       
    def readDataFrame(self):
        df_read = pandas.read_csv(self.string_db_path_full, error_bad_lines=False, usecols=self.list_db_headers)
        
        """
        If no header fields exist, the default first header field name is sha256_hash
        """
        if(self.list_db_headers == None):
            df_read.columns = ["sha256_hash"]
            
        return df_read
    
    """
    This function creates a full data frame constructed out of the raw database
    and the extra information extracted using the API extraction functions
    """
    def getFullDataFrame(self):
        
        """
        Read the current raw database into a dataframe
        """
        df_read = self.readDataFrame()
        dict_db_info = const_dict_extract_type_db.get(self.string_db_name, None)
        
        if(dict_db_info == None):
            print("[{0:s}]No such database type!".format(self.string_db_name))
            return False
        
        print("[{0:s}]Beggining extraction..".format(self.string_db_name))
        
        """
        cols = new columns to create
        hash_col = the name of the hash field
        func = a pointer to the database API handling function
        """
        cols = dict_db_info["columns"]
        hash_col = dict_db_info["hash_col"]
        func = dict_db_info["api_func"]
        
        """
        Create new dataframe to hold the new extracted values
        """
        df_newdata = pandas.DataFrame(columns = cols) 
        
        """
        For every row in the data frame
        """
        for index, row in df_read.iterrows():
            sha256_hash = row[hash_col]
            new_data = func(self.string_api_key, sha256_hash)
            df_newdata.loc[index] = new_data
            
        df_newdata = pandas.concat([df_read, df_newdata], axis=1, sort=False)
        self.dataframe_db = df_newdata
        return True
    
"""
This function merges two Database objects and creates a csv file out of them
IN db_first - A Database object
IN db_second - A database object    
"""
def generateFullDB(db_first, db_second):
    
    if(db_first.getFullDataFrame() == False):
        print("Failed to create the first full data frame!")
        return False
    
    df_db = db_first.dataframe_db
    
    if(db_second != None):
        if(db_second.getFullDataFrame() == False):
            print("Failed to create the second full data frame!")
            return False
         
        df_db = pandas.concat([db_first.dataframe_db, db_second.dataframe_db])
        df_db = df_db.drop_duplicates("sha256_hash")
        
    df_db["vtpercent"].fillna("-1", inplace=True)    
    df_db.fillna("n/a", inplace=True)
    
    bool_headers = False
    
    if not os.path.exists(current_main_db):
        bool_headers = True

    df_db.to_csv(current_main_db, index=False, mode="a", header=bool_headers)
    return True
