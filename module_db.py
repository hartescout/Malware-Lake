# -*- coding: utf-8 -*-
"""
Created on Fri Mar 27 15:59:40 2020

@author: Danus
"""
import os
import requests
import pandas
import module_api_parser as api_parser
from datetime import date

"""
A const dictionary containing extraction settings for each database type
"""
const_dict_extract_type_db = {
    "Bazaar": {"columns":["Tags", "Delivery", "Source"], 
               "hash_col": "sha256_hash", 
               "api_func": api_parser.getDataBazaar},
    "Malshare": {"columns":["first_seen_utc", "file_type_guess", "Tags"], 
                 "hash_col": "sha256_hash", 
                 "api_func": api_parser.getDataMalshare},
    }


current_date = str(date.today())

current_dir = os.getcwd()

"""
Location of the master database
"""
current_main_db = "{0:s}\Main_test.csv".format(current_dir)

"""
Database Constructor
IN string_db_name - Name of the database
IN string_api_key - API key of the database
IN string_db_source - URL Location of the database
IN list_db_headers - A list of header fields that will be used in the database
"""
class Database:
    
    def __init__(self, string_db_name, string_api_key, string_db_source, list_db_headers):
        self.string_db_name = string_db_name
        self.string_api_key = string_api_key
        self.string_db_source = string_db_source
        self.list_db_headers = list_db_headers
        
        self.string_db_path_full = "{0:s}/{1:s}/{2:s}_{3:s}.csv".format(
            current_dir,
            string_db_name,
            current_date, 
            string_db_name)
        
        self.string_db_path_dir = "{0:s}/{1:s}/".format(
            current_dir,
            string_db_name)
        
        self.dataframe_db = None
    
    """
    This function creates a raw database from the source provided to Database the object
    IN - Number of bytes to remove from the raw database outputp
    """    
    def createDatabase(self, num_trash_bytes):
        
        print("[{0:s}]Preparing Database creation!".format(self.string_db_name))
        
        """
        If the database folder doesnt exist, create it
        """
        if not os.path.exists(self.string_db_path_dir):
            os.mkdir(self.string_db_path_dir)
        
        """
        Check if a raw database already exists for the current date
        """
        if not os.path.exists(self.string_db_path_full):
            print("[{0:s}]Creating Database! URL:{1:s}".format(self.string_db_name, self.string_db_source))
            try:
                with requests.get(self.string_db_source) as response, open(self.string_db_path_full, 'wb' ) as out_file:
                    """
                    Cleans double qoutes and space character entries from the raw database
                    """
                    response_clean = response.content[num_trash_bytes:]
                    response_clean = response_clean.replace(b'\x20\x22', b'')
                    response_clean = response_clean.replace(b'\x22', b'')
                    out_file.write(response_clean)
            except Exception as e:
                print(e)
                print("[{0:s}]An error occurred during the database creation!".format(self.string_db_name))
            print("[{0:s}]Database created!".format(self.string_db_name))
        else:
            print("[{0:s}]Database already exists!".format(self.string_db_name))
            
        print()
    
    """
    This function creates a pandas dataframe from a raw database of the Database Object
    OUT - 
    """       
    def readDataFrame(self):
        df_read = pandas.read_csv(self.string_db_path_full, error_bad_lines=False, usecols=self.list_db_headers)
        
        """
        If no header fields exist, the default first header field name is sha256_hash
        """
        if(self.list_db_headers == None):
            df_read.columns = ["sha256_hash"]
            
        return df_read
    
    """
    This function creates a full data frame constructed out of the raw database
    and the extra information extracted using the API extraction functions
    """
    def getFullDataFrame(self):
        
        """
        Read the current raw database into a dataframe
        """
        df_read = self.readDataFrame()
        dict_db_info = const_dict_extract_type_db.get(self.string_db_name, None)
        
        if(dict_db_info == None):
            print("[{0:s}]No such database type!".format(self.string_db_name))
            return False
        
        print("[{0:s}]Beggining extraction..".format(self.string_db_name))
        
        """
        cols = new columns to create
        hash_col = the name of the hash field
        func = a pointer to the database API handling function
        """
        cols = dict_db_info["columns"]
        hash_col = dict_db_info["hash_col"]
        func = dict_db_info["api_func"]
        
        """
        Create new dataframe to hold the new extracted values
        """
        df_newdata = pandas.DataFrame(columns = cols) 
        
        """
        For every row in the data frame
        """
        for index, row in df_read.iterrows():
            sha256_hash = row[hash_col]
            new_data = func(self.string_api_key, sha256_hash)
            df_newdata.loc[index] = new_data
            
        df_newdata = pandas.concat([df_read, df_newdata], axis=1, sort=False)
        self.dataframe_db = df_newdata
        return True
    
"""
This function merges two Database objects and creates a csv file out of them
IN db_first - A Database object
IN db_second - A database object    
"""
def generateFullDB(db_first, db_second):
    
    if(db_first.getFullDataFrame() == False):
        print("Failed to create the first full data frame!")
        return False
    
    if(db_second.getFullDataFrame() == False):
        print("Failed to create the second full data frame!")
        return False
    
    bool_headers = False
    
    if not os.path.exists(current_main_db):
        bool_headers = True
        
    df_db = pandas.concat([db_first.dataframe_db, db_second.dataframe_db])
    df_db.fillna("n/a", inplace=True)
    df_db.to_csv(current_main_db, index=False, mode="a", header=bool_headers)
    return True
